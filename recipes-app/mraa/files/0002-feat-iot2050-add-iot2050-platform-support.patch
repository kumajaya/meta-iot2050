From a1bee1d7bd044a7658e54d894b5ffbfb33f58360 Mon Sep 17 00:00:00 2001
From: "le.jin" <le.jin@siemens.com>
Date: Fri, 24 May 2019 14:33:42 +0800
Subject: [PATCH 02/11] feat:iot2050:add iot2050 platform support

Add new iot2050 platform support with some modifications
due to lack of support with register level pin mux hooks.
Also add some examples for the iot2050 platform.

Signed-off-by: le.jin <le.jin@siemens.com>
---
 api/mraa/types.h                       |    1 +
 api/mraa/types.hpp                     |    1 +
 include/arm/siemens/iot2050.h          |   40 +
 include/arm/siemens/platform.h         |   97 ++
 include/arm/siemens/platform_iot2050.h |   34 +
 include/mraa_adv_func.h                |    2 +
 include/mraa_internal_types.h          |   13 +
 src/CMakeLists.txt                     |    3 +
 src/aio/aio.c                          |    7 +-
 src/arm/arm.c                          |    5 +
 src/arm/siemens/iot2050.c              | 1186 ++++++++++++++++++++++++
 src/arm/siemens/platform.c             |   41 +
 src/arm/siemens/platform_iot2050.c     |  367 ++++++++
 src/gpio/gpio.c                        |   14 +-
 src/i2c/i2c.c                          |   13 +-
 src/mraa.c                             |    1 +
 src/pwm/pwm.c                          |    7 +
 src/spi/spi.c                          |   28 +
 src/uart/uart.c                        |   34 +-
 19 files changed, 1890 insertions(+), 4 deletions(-)
 create mode 100644 include/arm/siemens/iot2050.h
 create mode 100644 include/arm/siemens/platform.h
 create mode 100644 include/arm/siemens/platform_iot2050.h
 create mode 100644 src/arm/siemens/iot2050.c
 create mode 100644 src/arm/siemens/platform.c
 create mode 100644 src/arm/siemens/platform_iot2050.c

diff --git a/api/mraa/types.h b/api/mraa/types.h
index c1fc288..d167e46 100644
--- a/api/mraa/types.h
+++ b/api/mraa/types.h
@@ -67,6 +67,7 @@ typedef enum {
     MRAA_ADLINK_LEC_AL = 22,        /**< Adlink LEC-AL*/
     MRAA_ADLINK_LEC_AL_AI = 23,        /**< Adlink LEC-AL*/
     MRAA_UPXTREME = 24,             /**< The UPXTREME Board */
+    MRAA_SIEMENS_IOT2050 = 25,      /**< Siemens IOT2050 board */
     // USB platform extenders start at 256
     MRAA_FTDI_FT4222 = 256,         /**< FTDI FT4222 USB to i2c bridge */
 
diff --git a/api/mraa/types.hpp b/api/mraa/types.hpp
index 3429982..c3fa7eb 100644
--- a/api/mraa/types.hpp
+++ b/api/mraa/types.hpp
@@ -61,6 +61,7 @@ typedef enum {
     MTK_OMEGA2 = 18,           /**< MT7688 based Onion Omega2 board */
     IEI_TANK = 19,             /**< IEI Tank System*/
     INTEL_UPXTREME = 24,        /**< The UPXTREME Board */
+    SIEMENS_IOT2050 = 25,      /**< Siemens IOT2050 board */
 
     FTDI_FT4222 = 256,         /**< FTDI FT4222 USB to i2c bridge */
 
diff --git a/include/arm/siemens/iot2050.h b/include/arm/siemens/iot2050.h
new file mode 100644
index 0000000..0acf0a0
--- /dev/null
+++ b/include/arm/siemens/iot2050.h
@@ -0,0 +1,40 @@
+/*
+ * Author: Le Jin <le.jin@siemens.com>
+ * Copyright (c) Siemens AG, 2019
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mraa_internal.h"
+
+#define PLATFORM_NAME                   "SIMATIC IOT2050"
+#define MRAA_IOT2050_PINCOUNT          (20)
+
+mraa_board_t *
+        mraa_siemens_iot2050();
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/include/arm/siemens/platform.h b/include/arm/siemens/platform.h
new file mode 100644
index 0000000..4203aa8
--- /dev/null
+++ b/include/arm/siemens/platform.h
@@ -0,0 +1,97 @@
+/*
+ * Author: Le Jin <le.jin@siemens.com>
+ * Copyright (c) Siemens AG, 2019
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _PLATFORM_H_
+#define _PLATFORM_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+typedef struct {
+    bool (*init)(void);
+    void (*deinit)(void);
+    void (*select_func)(uint8_t group, uint16_t pinIndex, uint8_t func);
+    void (*select_input)(uint8_t group, uint16_t pinIndex);
+    void (*select_output)(uint8_t group, uint16_t pinIndex);
+    void (*select_inout)(uint8_t group, uint16_t pinIndex);
+    void (*select_hiz)(uint8_t group, uint16_t pinIndex);
+    void (*select_pull_up)(uint8_t group, uint16_t pinIndex);
+    void (*select_pull_down)(uint8_t group, uint16_t pinIndex);
+    void (*select_pull_disable)(uint8_t group, uint16_t pinIndex);
+    uint32_t (*get_raw_reg_value)(uint8_t group, uint16_t pinIndex);
+    void (*set_raw_reg_value)(uint8_t group, uint16_t pinIndex, uint32_t value);
+    void (*dump_info)(uint8_t group, uint16_t pinIndex);
+}PinMuxOps_t;
+
+typedef struct{
+    bool            initialized;
+    PinMuxOps_t     ops;
+}PinMuxInterface_t;
+
+#define VOID_INTERFACE_CALL(instance, function) \
+do {\
+        if((instance) && ((PinMuxInterface_t *)instance)->ops.function) \
+            ((PinMuxInterface_t *)instance)->ops.function(); \
+}while(0)
+
+#define VOID_INTERFACE_CALL_WITH_ARGS(instance, function, ...) \
+do {\
+        if((instance) && ((PinMuxInterface_t *)instance)->ops.function) \
+            ((PinMuxInterface_t *)instance)->ops.function(__VA_ARGS__); \
+}while(0)
+
+#define INTERFACE_CALL_WITH_ARGS(instance, retType, defaultRetValue, function, ...) \
+( \
+    { \
+        retType ret = defaultRetValue; \
+        if((instance) && ((PinMuxInterface_t *)instance)->ops.function) \
+            ret = ((PinMuxInterface_t *)instance)->ops.function(__VA_ARGS__); \
+        ret; \
+    } \
+)
+
+#ifdef _DEBUG
+#define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)
+#else
+#define DEBUG_PRINT(...) do{}while(0)
+#endif
+
+void *platfrom_pinmux_get_instance(char *platform);
+#define platform_pinmux_release_instance(instance) VOID_INTERFACE_CALL(instance, deinit)
+#define platform_pinmux_select_func(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_func, __VA_ARGS__)
+#define platform_pinmux_select_input(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_input, __VA_ARGS__)
+#define platform_pinmux_select_output(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_output, __VA_ARGS__)
+#define platform_pinmux_select_inout(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_inout, __VA_ARGS__)
+#define platform_pinmux_select_hiz(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_hiz, __VA_ARGS__)
+#define platform_pinmux_select_pull_up(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_pull_up, __VA_ARGS__)
+#define platform_pinmux_select_pull_down(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_pull_down, __VA_ARGS__)
+#define platform_pinmux_select_pull_disable(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, select_pull_disable, __VA_ARGS__)
+#define platform_pinmux_get_raw_reg_value(instance, ...) INTERFACE_CALL_WITH_ARGS(instance, uint32_t, -1, get_raw_reg_value, __VA_ARGS__)
+#define platform_pinmux_set_raw_reg_value(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, set_raw_reg_value, __VA_ARGS__)
+#define platform_pinmux_dump_info(instance, ...) VOID_INTERFACE_CALL_WITH_ARGS(instance, dump_info, __VA_ARGS__)
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/include/arm/siemens/platform_iot2050.h b/include/arm/siemens/platform_iot2050.h
new file mode 100644
index 0000000..504851b
--- /dev/null
+++ b/include/arm/siemens/platform_iot2050.h
@@ -0,0 +1,34 @@
+/*
+ * Author: Le Jin <le.jin@siemens.com>
+ * Copyright (c) Siemens AG, 2019
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _PLATFORM_IOT2050_H_
+#define _PLATFORM_IOT2050_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "arm/siemens/platform.h"
+PinMuxInterface_t *iot2050_pinmux_get_instance(void);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/include/mraa_adv_func.h b/include/mraa_adv_func.h
index 312a2d9..1ae202b 100644
--- a/include/mraa_adv_func.h
+++ b/include/mraa_adv_func.h
@@ -106,4 +106,6 @@ typedef struct {
     int (*uart_read_replace) (mraa_uart_context dev, char* buf, size_t len);
     int (*uart_write_replace)(mraa_uart_context dev, const char* buf, size_t len);
     mraa_boolean_t (*uart_data_available_replace) (mraa_uart_context dev, unsigned int millis);
+
+    mraa_result_t (*setup_mux_register) (int phy_pin, int mode);
 } mraa_adv_func_t;
diff --git a/include/mraa_internal_types.h b/include/mraa_internal_types.h
index 207666a..3a8eafe 100644
--- a/include/mraa_internal_types.h
+++ b/include/mraa_internal_types.h
@@ -313,6 +313,19 @@ typedef enum {
 } pincmd_t;
 
 
+/**
+ * Enum representing different mux register mode
+ */
+ typedef enum {
+     MUX_REGISTER_MODE_GPIO = 0,    /**< GPIO mode */
+     MUX_REGISTER_MODE_UART = 1,    /**< UART mode */
+     MUX_REGISTER_MODE_I2C = 2,     /**< I2C mode */
+     MUX_REGISTER_MODE_SPI = 3,     /**< SPI mode */
+     MUX_REGISTER_MODE_PWM = 4,     /**< PWM mode */
+     MUX_REGISTER_MODE_AIO = 5,     /**< AIO mode */
+     MAX_MUX_REGISTER_MODE
+ } mux_register_mode_t;
+
 /**
  * A Structure representing a multiplexer and the required value
  */
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 6cfb72e..aaad178 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -107,6 +107,9 @@ set (mraa_LIB_ARM_SRCS_NOAUTO
   ${PROJECT_SOURCE_DIR}/src/arm/de_nano_soc.c
   ${PROJECT_SOURCE_DIR}/src/arm/rockpi4.c
   ${PROJECT_SOURCE_DIR}/src/arm/adlink_ipi.c
+  ${PROJECT_SOURCE_DIR}/src/arm/siemens/iot2050.c
+  ${PROJECT_SOURCE_DIR}/src/arm/siemens/platform.c
+  ${PROJECT_SOURCE_DIR}/src/arm/siemens/platform_iot2050.c
 )
 
 set (mraa_LIB_MIPS_SRCS_NOAUTO
diff --git a/src/aio/aio.c b/src/aio/aio.c
index 7a94ac1..352c893 100644
--- a/src/aio/aio.c
+++ b/src/aio/aio.c
@@ -119,7 +119,12 @@ mraa_aio_init(unsigned int aio)
             return NULL;
         }
     }
-
+    if (board->adv_func->setup_mux_register) {
+        if(board->adv_func->setup_mux_register(pin, MUX_REGISTER_MODE_AIO) != MRAA_SUCCESS) {
+            syslog(LOG_ERR, "aio: unable to setup multiplex register for pin");
+            return NULL;
+        }
+    }
     // Create ADC device connected to specified channel
     mraa_aio_context dev = mraa_aio_init_internal(board->adv_func, aio, board->pins[pin].aio.pinmap);
     if (dev == NULL) {
diff --git a/src/arm/arm.c b/src/arm/arm.c
index df88e7e..0a44d0f 100644
--- a/src/arm/arm.c
+++ b/src/arm/arm.c
@@ -17,6 +17,7 @@
 #include "arm/phyboard.h"
 #include "arm/raspberry_pi.h"
 #include "arm/adlink_ipi.h"
+#include "arm/siemens/iot2050.h"
 #include "mraa_internal.h"
 
 
@@ -98,6 +99,8 @@ mraa_arm_platform()
             platform_type = MRAA_RASPBERRY_PI;
         else if (mraa_file_contains("/proc/device-tree/model", "ADLINK ARM, LEC-PX30"))
             platform_type = MRAA_ADLINK_IPI;
+        else if (mraa_file_contains("/proc/device-tree/model", "SIMATIC IOT2050"))
+            platform_type = MRAA_SIEMENS_IOT2050;
     }
 
     switch (platform_type) {
@@ -124,6 +127,8 @@ mraa_arm_platform()
             break;
         case MRAA_ADLINK_IPI:
             plat = mraa_adlink_ipi();
+        case MRAA_SIEMENS_IOT2050:
+            plat = mraa_siemens_iot2050();
             break;
         default:
             plat = NULL;
diff --git a/src/arm/siemens/iot2050.c b/src/arm/siemens/iot2050.c
new file mode 100644
index 0000000..0035404
--- /dev/null
+++ b/src/arm/siemens/iot2050.c
@@ -0,0 +1,1186 @@
+/*
+ * Author: Le Jin <le.jin@siemens.com>
+ * Copyright (c) Siemens AG, 2019
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <mraa/types.h>
+
+#include "common.h"
+#include "arm/siemens/iot2050.h"
+#include "arm/siemens/platform.h"
+
+#define PINMUX_GROUP_MAIN       (0)
+#define PINMUX_GROUP_WAKUP      (1)
+#define MAIN_GPIO0_BASE         (0)
+#define WKUP_GPIO0_BASE         (186)
+#define D4200_GPIO_BASE         (496)
+#define D4201_GPIO_BASE         (480)
+#define D4202_GPIO_BASE         (464)
+
+typedef struct {
+    uint8_t     group;
+    uint16_t    index;
+    uint16_t    pinmap;
+    int8_t      mode[MAX_MUX_REGISTER_MODE];
+}regmux_info_t;
+
+static void *pinmux_instance = NULL;
+static regmux_info_t pinmux_info[MRAA_IOT2050_PINCOUNT];
+static mraa_gpio_context output_en_pins[MRAA_IOT2050_PINCOUNT];
+static int pull_en_pins[MRAA_IOT2050_PINCOUNT];
+
+static inline int
+iot2050_locate_phy_pin_by_name(mraa_board_t *board, char *pin_name)
+{
+    int i;
+
+    if(!pin_name)
+        return -1;
+    for(i=0; i<board->phy_pin_count; i++) {
+        if(!strncmp(board->pins[i].name, pin_name, MRAA_PIN_NAME_SIZE)) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+static inline regmux_info_t*
+iot2050_get_regmux_by_pinmap(int pinmap)
+{
+    int i;
+
+    for(i=0; i<MRAA_IOT2050_PINCOUNT; i++) {
+        if((pinmux_info[i].mode[MUX_REGISTER_MODE_GPIO] != -1) && 
+            (pinmux_info[i].pinmap == pinmap)) {
+            return &pinmux_info[i];
+        }
+    }
+    return NULL;
+}
+
+static mraa_result_t
+iot2050_setup_mux_register(int phy_pin, int mode)
+{
+    regmux_info_t *info = &pinmux_info[phy_pin];
+    int8_t mux_mode;
+
+    if((phy_pin < 0) || (phy_pin > MRAA_IOT2050_PINCOUNT))
+        return MRAA_SUCCESS;
+    if((mode < 0) || (mode >= MAX_MUX_REGISTER_MODE)) {
+        return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+    }
+    if(mode == MUX_REGISTER_MODE_AIO) {
+        return MRAA_SUCCESS;
+    }
+    mux_mode = info->mode[mode];
+    if(mux_mode < 0) {
+        return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+    }
+    syslog(LOG_DEBUG, "REGMUX[phy_pin %d] group %d index %d mode %d\n", phy_pin, info->group, info->index, mux_mode);
+
+    platform_pinmux_select_func(pinmux_instance, info->group, info->index, mux_mode);
+    /* Configure as input and output for default */
+    platform_pinmux_select_inout(pinmux_instance, info->group, info->index);
+    return MRAA_SUCCESS;
+}
+
+static mraa_result_t
+iot2050_gpio_dir_pre(mraa_gpio_context dev, mraa_gpio_dir_t dir)
+{
+    int pin = dev->phy_pin;
+
+    if(pin >= 0) {
+        if(plat->pins[pin].gpio.complex_cap.complex_pin != 1) {
+            return MRAA_SUCCESS;
+        }
+        if(plat->pins[pin].gpio.complex_cap.output_en == 1) {
+            if(output_en_pins[pin] == NULL) {
+                output_en_pins[pin] = mraa_gpio_init_raw(plat->pins[pin].gpio.output_enable);
+                if(output_en_pins[pin]) {
+                    if(mraa_gpio_dir(output_en_pins[pin], MRAA_GPIO_OUT) != MRAA_SUCCESS) {
+                        mraa_gpio_close(output_en_pins[pin]);
+                        output_en_pins[pin] = NULL;
+                        goto failed;
+                    }
+                } else {
+                    goto failed;
+                }
+            }
+            if(dir == MRAA_GPIO_IN) {
+                syslog(LOG_DEBUG, "GPIODIR[phy_pin %d] gpio set out en %d to %d\n", pin, plat->pins[pin].gpio.output_enable, !plat->pins[pin].gpio.complex_cap.output_en_high);
+                if(mraa_gpio_write(output_en_pins[pin], !plat->pins[pin].gpio.complex_cap.output_en_high) != MRAA_SUCCESS) {
+                    goto failed;
+                }
+            } else {
+                syslog(LOG_DEBUG, "GPIODIR[phy_pin %d] gpio set out en %d to %d\n", pin, plat->pins[pin].gpio.output_enable, plat->pins[pin].gpio.complex_cap.output_en_high);
+                if(mraa_gpio_write(output_en_pins[pin], plat->pins[pin].gpio.complex_cap.output_en_high) != MRAA_SUCCESS) {
+                    goto failed;
+                }
+            }
+        }
+    }
+    return MRAA_SUCCESS;
+failed:
+    syslog(LOG_ERR, "iot2050: Error setting gpio direction");
+    return MRAA_ERROR_INVALID_RESOURCE;
+}
+
+static mraa_result_t
+iot2050_gpio_mode_replace(mraa_gpio_context dev, mraa_gpio_mode_t mode)
+{
+    regmux_info_t *info;
+    mraa_gpio_context pull_en_pin;
+    mraa_result_t ret = MRAA_SUCCESS;
+
+    /* Only support mode change on interface pins */
+    if(dev->phy_pin == -1) {
+        ret = MRAA_ERROR_INVALID_RESOURCE;
+        goto failed;
+    }
+    info = iot2050_get_regmux_by_pinmap(dev->pin);
+    pull_en_pin = mraa_gpio_init_raw(pull_en_pins[dev->phy_pin]);
+    if(pull_en_pin == NULL) {
+        ret = MRAA_ERROR_INVALID_RESOURCE;
+        goto failed;
+    }
+    switch(mode) {
+        case MRAA_GPIO_PULLUP:
+            if(mraa_gpio_dir(pull_en_pin, MRAA_GPIO_OUT_HIGH) != MRAA_SUCCESS) {
+                ret = MRAA_ERROR_INVALID_RESOURCE;
+                goto failed;
+            }
+            if(info) {
+                platform_pinmux_select_pull_up(pinmux_instance, info->group, info->index);
+            }
+            break;
+        case MRAA_GPIO_PULLDOWN:
+            if(mraa_gpio_dir(pull_en_pin, MRAA_GPIO_OUT_LOW) != MRAA_SUCCESS) {
+                ret = MRAA_ERROR_INVALID_RESOURCE;
+                goto failed;
+            }
+            if(info) {
+                platform_pinmux_select_pull_down(pinmux_instance, info->group, info->index);
+            }
+            break;
+        case MRAA_GPIO_HIZ:
+        case MRAA_GPIO_STRONG:
+            if(mraa_gpio_dir(pull_en_pin, MRAA_GPIO_IN) != MRAA_SUCCESS) {
+                ret = MRAA_ERROR_INVALID_RESOURCE;
+                goto failed;
+            }
+            if(info) {
+                platform_pinmux_select_pull_disable(pinmux_instance, info->group, info->index);
+            }
+            break;
+        case MRAA_GPIOD_ACTIVE_LOW:
+        case MRAA_GPIOD_OPEN_DRAIN:
+        case MRAA_GPIOD_OPEN_SOURCE:
+        default:
+            ret = MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+            goto failed;
+    }
+    mraa_gpio_close(pull_en_pin);
+    return ret;
+failed:
+    syslog(LOG_ERR, "iot2050: Error setting gpio mode");
+    if(pull_en_pin) {
+        mraa_gpio_close(pull_en_pin);
+    }
+    return ret;
+}
+
+static inline void
+iot2050_setup_pins(mraa_board_t *board, int pin_index, char *pin_name, mraa_pincapabilities_t cap, regmux_info_t mux_info)
+{
+    strncpy(board->pins[pin_index].name, pin_name, MRAA_PIN_NAME_SIZE);
+    board->pins[pin_index].capabilities = cap;
+    pinmux_info[pin_index] = mux_info;
+}
+
+static inline void
+iot2050_pin_add_gpio(mraa_board_t *board, int pin_index, int chip, int line,
+                        int output_en_pin, int pull_en_pin, mraa_mux_t *pin_mux, int num_pinmux)
+{
+    int i;
+
+    mraa_pininfo_t *pininfo = &(board->pins[pin_index]);
+    /*for sysfs*/
+    pininfo->gpio.pinmap = pinmux_info[pin_index].pinmap;
+    pininfo->gpio.mux_total = 0;
+    /*for gpio chardev*/
+    pininfo->gpio.gpio_chip = chip;
+    pininfo->gpio.gpio_line = line;
+    for(i=0; i<num_pinmux; i++) {
+        pininfo->gpio.mux[i] = pin_mux[i];
+    }
+    pininfo->gpio.mux_total = num_pinmux;
+    /*output enable pin*/
+    if(output_en_pin != -1)
+    {
+        pininfo->gpio.complex_cap = (mraa_pin_cap_complex_t){ 1, 1, 1, 0, 0 };
+        pininfo->gpio.output_enable = output_en_pin;
+        pininfo->gpio.complex_cap.output_en_high = 1;
+    }
+    /*pull enabled pin*/
+    pull_en_pins[pin_index] = pull_en_pin;
+    board->gpio_count++;
+}
+
+static inline void
+iot2050_pin_add_aio(mraa_board_t *board, int pin_index, int channel, mraa_mux_t *pin_mux, int num_pinmux)
+{
+    int i;
+
+    mraa_pininfo_t *pininfo = &(board->pins[pin_index]);
+    pininfo->aio.pinmap = channel;
+    for(i=0; i<num_pinmux; i++) {
+        pininfo->aio.mux[i] = pin_mux[i];
+    }
+    pininfo->aio.mux_total = num_pinmux;
+    board->aio_dev[channel].pin = pin_index;
+    board->aio_count++;
+}
+
+static inline void
+iot2050_pin_add_uart(mraa_board_t *board, int pin_index, int parent_id, mraa_mux_t *pin_mux, int num_pinmux)
+{
+    int i;
+
+    mraa_pininfo_t *pininfo = &(board->pins[pin_index]);
+    pininfo->uart.parent_id = parent_id;
+    for(i=0; i<num_pinmux; i++) {
+        pininfo->uart.mux[i] = pin_mux[i];
+    }
+    pininfo->uart.mux_total = num_pinmux;
+}
+
+static inline void
+iot2050_pin_add_i2c(mraa_board_t *board, int pin_index, int parent_id, mraa_mux_t *pin_mux, int num_pinmux)
+{
+    int i;
+
+    mraa_pininfo_t *pininfo = &(board->pins[pin_index]);
+    pininfo->i2c.parent_id = parent_id;
+    for(i=0; i<num_pinmux; i++) {
+        pininfo->i2c.mux[i] = pin_mux[i];
+    }
+    pininfo->i2c.mux_total = num_pinmux;
+}
+
+static inline void
+iot2050_pin_add_spi(mraa_board_t *board, int pin_index, int parent_id, mraa_mux_t *pin_mux, int num_pinmux)
+{
+    int i;
+
+    mraa_pininfo_t *pininfo = &(board->pins[pin_index]);
+    pininfo->spi.parent_id = parent_id;
+    for(i=0; i<num_pinmux; i++) {
+        pininfo->spi.mux[i] = pin_mux[i];
+    }
+    pininfo->spi.mux_total = num_pinmux;
+}
+
+static inline void
+iot2050_pin_add_pwm(mraa_board_t *board, int pin_index, int parent_id, int pinmap, mraa_mux_t *pin_mux, int num_pinmux)
+{
+    int i;
+
+    mraa_pininfo_t *pininfo = &(board->pins[pin_index]);
+    pininfo->pwm.parent_id = parent_id;
+    pininfo->pwm.pinmap = pinmap;
+    for(i=0; i<num_pinmux; i++) {
+        pininfo->pwm.mux[i] = pin_mux[i];
+    }
+    pininfo->pwm.mux_total = num_pinmux;
+}
+
+
+static inline void
+iot2050_setup_uart(mraa_board_t *board, char *name, char *path, char *rx_pin_name, char *tx_pin_name, char *cts_pin_name, char *rts_pin_name)
+{
+    board->uart_dev[board->uart_dev_count].name = name;
+    board->uart_dev[board->uart_dev_count].device_path = path;
+    board->uart_dev[board->uart_dev_count].tx = iot2050_locate_phy_pin_by_name(board, tx_pin_name);
+    board->uart_dev[board->uart_dev_count].rx = iot2050_locate_phy_pin_by_name(board, rx_pin_name);
+    board->uart_dev[board->uart_dev_count].rts = iot2050_locate_phy_pin_by_name(board, rts_pin_name);
+    board->uart_dev[board->uart_dev_count].cts = iot2050_locate_phy_pin_by_name(board, cts_pin_name);
+    board->uart_dev_count++;
+}
+
+static inline void
+iot2050_setup_i2c(mraa_board_t *board, char *name, int bus_id, char *sda_pin_name, char *scl_pin_name)
+{
+    board->i2c_bus[board->i2c_bus_count].name = name;
+    board->i2c_bus[board->i2c_bus_count].bus_id = bus_id;
+    board->i2c_bus[board->i2c_bus_count].sda = iot2050_locate_phy_pin_by_name(board, sda_pin_name);
+    board->i2c_bus[board->i2c_bus_count].scl = iot2050_locate_phy_pin_by_name(board, scl_pin_name);
+    board->i2c_bus_count++;
+}
+
+static inline void
+iot2050_setup_spi(mraa_board_t *board, char *name, int bus_id, int cs_id,
+                                        char *sclk_pin_name, char *mosi_pin_name,
+                                        char *miso_pin_name, char *cs_pin_name)
+{
+    board->spi_bus[board->spi_bus_count].name = name;
+    board->spi_bus[board->spi_bus_count].bus_id = bus_id;
+    board->spi_bus[board->spi_bus_count].slave_s = cs_id;
+    board->spi_bus[board->spi_bus_count].sclk = iot2050_locate_phy_pin_by_name(board, sclk_pin_name);
+    board->spi_bus[board->spi_bus_count].mosi = iot2050_locate_phy_pin_by_name(board, mosi_pin_name);
+    board->spi_bus[board->spi_bus_count].miso = iot2050_locate_phy_pin_by_name(board, miso_pin_name);
+    board->spi_bus[board->spi_bus_count].cs = iot2050_locate_phy_pin_by_name(board, cs_pin_name);
+    board->spi_bus_count++;
+}
+
+static inline void
+iot2050_setup_pwm(mraa_board_t *board, char *name)
+{
+    board->pwm_dev[board->pwm_dev_count].name = name;
+    board->pwm_dev_count++;
+}
+
+static inline void
+iot2050_setup_led(mraa_board_t *board, char *name)
+{
+    board->led_dev[board->led_dev_count].name = name;
+    board->led_dev_count++;
+}
+
+mraa_board_t*
+mraa_siemens_iot2050()
+{
+    mraa_board_t* b = (mraa_board_t*) calloc(1, sizeof(mraa_board_t));
+    mraa_mux_t mux_info[6];
+    int pin_index = 0;
+
+    if(b == NULL) {
+        return NULL;
+    }
+    memset(output_en_pins, 0, sizeof(mraa_gpio_context) * MRAA_IOT2050_PINCOUNT);
+    b->platform_name = PLATFORM_NAME;
+    b->phy_pin_count = MRAA_IOT2050_PINCOUNT;
+    b->chardev_capable = 0;
+    b->adc_raw = 12;
+    b->adc_supported = 12;
+    b->pwm_default_period = 1000; /*us*/
+    b->pwm_max_period = 939509;
+    b->pwm_min_period = 1;
+    b->aio_non_seq = 1;
+    b->adv_func = (mraa_adv_func_t*) calloc(1, sizeof(mraa_adv_func_t));
+    if(b->adv_func == NULL) {
+        goto error;
+    }
+    b->adv_func->gpio_dir_pre = &iot2050_gpio_dir_pre;
+    b->adv_func->gpio_mode_replace = &iot2050_gpio_mode_replace;
+    b->adv_func->setup_mux_register = &iot2050_setup_mux_register;
+    b->pins = (mraa_pininfo_t*) calloc(MRAA_IOT2050_PINCOUNT, sizeof(mraa_pininfo_t));
+    if(b->pins == NULL) {
+        free(b->adv_func);
+        goto error;
+    }
+    pinmux_instance = platfrom_pinmux_get_instance("iot2050");
+    /* IO */
+    iot2050_setup_pins(b, pin_index, "IO0",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            1}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            17,
+                            WKUP_GPIO0_BASE+29,
+                            {
+                                7,  /*GPIO*/
+                                4,  /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+
+    iot2050_pin_add_gpio(b, pin_index, 2, 29, D4201_GPIO_BASE+0, D4202_GPIO_BASE+0, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+0;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    mux_info[1].pin = D4202_GPIO_BASE+0;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_uart(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO1",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            1}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            18,
+                            WKUP_GPIO0_BASE+30,
+                            {
+                                7,  /*GPIO*/
+                                4,  /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 30, D4201_GPIO_BASE+1, D4202_GPIO_BASE+1, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+1;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+1;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_uart(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO2",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            1}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            19,
+                            WKUP_GPIO0_BASE+31,
+                            {
+                                7,  /*GPIO*/
+                                4,  /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 31, D4201_GPIO_BASE+2, D4202_GPIO_BASE+2, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+2;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    mux_info[1].pin = D4202_GPIO_BASE+2;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_uart(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO3",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            1}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            21,
+                            WKUP_GPIO0_BASE+33,
+                            {
+                                7,  /*GPIO*/
+                                4,  /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 33, D4201_GPIO_BASE+3, D4202_GPIO_BASE+3, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+3;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+3;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_uart(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO4",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            1,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_MAIN,
+                            33,
+                            MAIN_GPIO0_BASE+33,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                5   /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 0, 33, D4201_GPIO_BASE+4, D4202_GPIO_BASE+4, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+4;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+4;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_pwm(b, pin_index, 0, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO5",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            1,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_MAIN,
+                            35,
+                            MAIN_GPIO0_BASE+35,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                5   /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 0, 35, D4201_GPIO_BASE+5, D4202_GPIO_BASE+5, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+5;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+5;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_pwm(b, pin_index, 2, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO6",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            1,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_MAIN,
+                            38,
+                            MAIN_GPIO0_BASE+38,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                5   /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 0, 38, D4201_GPIO_BASE+6, D4202_GPIO_BASE+6, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+6;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+6;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_pwm(b, pin_index, 4, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO7",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            1,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_MAIN,
+                            43,
+                            MAIN_GPIO0_BASE+43,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                5   /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 0, 43, D4201_GPIO_BASE+7, D4202_GPIO_BASE+7, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+7;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+7;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_pwm(b, pin_index, 6, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO8",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            1,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_MAIN,
+                            48,
+                            MAIN_GPIO0_BASE+48,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                5   /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 0, 48, D4201_GPIO_BASE+8, D4202_GPIO_BASE+8, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+8;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+8;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_pwm(b, pin_index, 8, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO9",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            1,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_MAIN,
+                            51,
+                            MAIN_GPIO0_BASE+51,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                5   /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 0, 51, D4201_GPIO_BASE+9, D4202_GPIO_BASE+9, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+9;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+9;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_pwm(b, pin_index, 10, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO10",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            1,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            39,
+                            WKUP_GPIO0_BASE+51,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                0, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 51, D4201_GPIO_BASE+10, D4202_GPIO_BASE+10, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+10;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+10;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_spi(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO11",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            1,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            37,
+                            WKUP_GPIO0_BASE+49,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                0, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 49, D4201_GPIO_BASE+11, D4202_GPIO_BASE+11, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+11;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+11;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_spi(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO12",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            1,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            38,
+                            WKUP_GPIO0_BASE+50,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                0, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 50, D4201_GPIO_BASE+12, D4202_GPIO_BASE+12, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+12;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    mux_info[1].pin = D4202_GPIO_BASE+12;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_spi(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "IO13",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            1,  /*spi*/
+                            0,  /*i2c*/
+                            0,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            36,
+                            WKUP_GPIO0_BASE+48,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                0, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    iot2050_pin_add_gpio(b, pin_index, 2, 48, D4201_GPIO_BASE+13, D4202_GPIO_BASE+13, NULL, 0);
+    mux_info[0].pin = D4201_GPIO_BASE+13;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_HIGH;
+    mux_info[1].pin = D4202_GPIO_BASE+13;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    iot2050_pin_add_spi(b, pin_index, 0, mux_info, 2);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "A0",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            1,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            33,
+                            WKUP_GPIO0_BASE+45,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    mux_info[0].pin = D4200_GPIO_BASE+8;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    iot2050_pin_add_gpio(b, pin_index, 2, 45, WKUP_GPIO0_BASE+38, D4200_GPIO_BASE+0, mux_info, 1);
+    // D/A switch
+    mux_info[0].pin = D4200_GPIO_BASE+8;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    // muxed GPIO as input
+    mux_info[1].pin = WKUP_GPIO0_BASE+45;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    // output enable as input
+    mux_info[2].pin = WKUP_GPIO0_BASE+38;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_OUT_LOW;
+    // pull enable as input
+    mux_info[3].pin = D4200_GPIO_BASE+0;
+    mux_info[3].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[3].value = MRAA_GPIO_IN;
+    iot2050_pin_add_aio(b, pin_index, 0, mux_info, 4);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "A1",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            1,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            32,
+                            WKUP_GPIO0_BASE+44,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    mux_info[0].pin = D4200_GPIO_BASE+9;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    iot2050_pin_add_gpio(b, pin_index, 2, 44, WKUP_GPIO0_BASE+37, D4200_GPIO_BASE+1, mux_info, 1);
+    // D/A switch
+    mux_info[0].pin = D4200_GPIO_BASE+9;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    // muxed GPIO as input
+    mux_info[1].pin = WKUP_GPIO0_BASE+44;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    // output enable as input
+    mux_info[2].pin = WKUP_GPIO0_BASE+37;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_OUT_LOW;
+    // pull enable as input
+    mux_info[3].pin = D4200_GPIO_BASE+1;
+    mux_info[3].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[3].value = MRAA_GPIO_IN;
+    iot2050_pin_add_aio(b, pin_index, 1, mux_info, 4);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "A2",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            1,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            31,
+                            WKUP_GPIO0_BASE+43,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    mux_info[0].pin = D4200_GPIO_BASE+10;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    iot2050_pin_add_gpio(b, pin_index, 2, 43, WKUP_GPIO0_BASE+36, D4200_GPIO_BASE+2, mux_info, 1);
+    // D/A switch
+    mux_info[0].pin = D4200_GPIO_BASE+10;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    // muxed GPIO as input
+    mux_info[1].pin = WKUP_GPIO0_BASE+43;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    // output enable as input
+    mux_info[2].pin = WKUP_GPIO0_BASE+36;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_OUT_LOW;
+    // pull enable as input
+    mux_info[3].pin = D4200_GPIO_BASE+2;
+    mux_info[3].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[3].value = MRAA_GPIO_IN;
+    iot2050_pin_add_aio(b, pin_index, 2, mux_info, 4);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "A3",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            0,  /*i2c*/
+                            1,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            27,
+                            WKUP_GPIO0_BASE+39,
+                            {
+                                7,  /*GPIO*/
+                                -1, /*UART*/
+                                -1, /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    mux_info[0].pin = D4200_GPIO_BASE+11;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    iot2050_pin_add_gpio(b, pin_index, 2, 39, WKUP_GPIO0_BASE+34, D4200_GPIO_BASE+3, mux_info, 1);
+    // D/A switch
+    mux_info[0].pin = D4200_GPIO_BASE+11;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    // muxed GPIO as input
+    mux_info[1].pin = WKUP_GPIO0_BASE+39;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_IN;
+    // output enable as input
+    mux_info[2].pin = WKUP_GPIO0_BASE+34;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_OUT_LOW;
+    // pull enable as input
+    mux_info[3].pin = D4200_GPIO_BASE+3;
+    mux_info[3].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[3].value = MRAA_GPIO_IN;
+    iot2050_pin_add_aio(b, pin_index, 3, mux_info, 4);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "A4",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            1,  /*i2c*/
+                            1,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            30,
+                            WKUP_GPIO0_BASE+42,
+                            {
+                                7, /*GPIO*/
+                                -1, /*UART*/
+                                0,  /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    mux_info[0].pin = D4200_GPIO_BASE+12;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    mux_info[1].pin = WKUP_GPIO0_BASE+21;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_OUT_HIGH;
+    iot2050_pin_add_gpio(b, pin_index, 2, 42, WKUP_GPIO0_BASE+41, D4200_GPIO_BASE+4, mux_info, 2);
+    // A/D/I switch
+    mux_info[0].pin = D4200_GPIO_BASE+12;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    mux_info[1].pin = WKUP_GPIO0_BASE+21;
+    mux_info[1].pincmd = PINCMD_SET_OUT_VALUE;
+    mux_info[1].value = 0;
+    // pull enable as input
+    mux_info[2].pin = D4200_GPIO_BASE+4;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_IN;
+    iot2050_pin_add_i2c(b, pin_index, 0, mux_info, 3);
+    // A/D/I switch
+    mux_info[0].pin = D4200_GPIO_BASE+12;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    mux_info[1].pin = WKUP_GPIO0_BASE+21;
+    mux_info[1].pincmd = PINCMD_SET_OUT_VALUE;
+    mux_info[1].value = 1;
+    // muxed GPIO as input
+    mux_info[2].pin = WKUP_GPIO0_BASE+42;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_IN;
+    // output enable as input
+    mux_info[3].pin = WKUP_GPIO0_BASE+41;
+    mux_info[3].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[3].value = MRAA_GPIO_OUT_LOW;
+    // pull enable as input
+    mux_info[4].pin = D4200_GPIO_BASE+4;
+    mux_info[4].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[4].value = MRAA_GPIO_IN;
+    iot2050_pin_add_aio(b, pin_index, 4, mux_info, 5);
+    pin_index++;
+
+    iot2050_setup_pins(b, pin_index, "A5",
+                        (mraa_pincapabilities_t) {
+                            1,  /*valid*/
+                            1,  /*gpio*/
+                            0,  /*pwm*/
+                            0,  /*fast gpio*/
+                            0,  /*spi*/
+                            1,  /*i2c*/
+                            1,  /*aio*/
+                            0}, /*uart*/
+                        (regmux_info_t) {
+                            PINMUX_GROUP_WAKUP,
+                            23,
+                            WKUP_GPIO0_BASE+35,
+                            {
+                                7, /*GPIO*/
+                                -1, /*UART*/
+                                0,  /*I2C*/
+                                -1, /*SPI*/
+                                -1  /*PWM*/
+                            }
+                        });
+    mux_info[0].pin = D4200_GPIO_BASE+13;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_OUT_LOW;
+    mux_info[1].pin = WKUP_GPIO0_BASE+21;
+    mux_info[1].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[1].value = MRAA_GPIO_OUT_HIGH;
+    iot2050_pin_add_gpio(b, pin_index, 2, 35, D4201_GPIO_BASE+14, D4200_GPIO_BASE+5, mux_info, 2);
+    // A/D/I switch
+    mux_info[0].pin = D4200_GPIO_BASE+13;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    mux_info[1].pin = WKUP_GPIO0_BASE+21;
+    mux_info[1].pincmd = PINCMD_SET_OUT_VALUE;
+    mux_info[1].value = 0;
+    // pull enable as input
+    mux_info[2].pin = D4200_GPIO_BASE+5;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_IN;
+    iot2050_pin_add_i2c(b, pin_index, 0, mux_info, 3);
+    // A/D/I switch
+    mux_info[0].pin = D4200_GPIO_BASE+13;
+    mux_info[0].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[0].value = MRAA_GPIO_IN;
+    mux_info[1].pin = WKUP_GPIO0_BASE+21;
+    mux_info[1].pincmd = PINCMD_SET_OUT_VALUE;
+    mux_info[1].value = 1;
+    // muxed GPIO as input
+    mux_info[2].pin = WKUP_GPIO0_BASE+35;
+    mux_info[2].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[2].value = MRAA_GPIO_IN;
+    // output enable as input
+    mux_info[3].pin = D4201_GPIO_BASE+14;
+    mux_info[3].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[3].value = MRAA_GPIO_OUT_LOW;
+    // pull enable as input
+    mux_info[4].pin = D4200_GPIO_BASE+5;
+    mux_info[4].pincmd = PINCMD_SET_DIRECTION;
+    mux_info[4].value = MRAA_GPIO_IN;
+    iot2050_pin_add_aio(b, pin_index, 5, mux_info, 5);
+    pin_index++;
+
+    /* UART */
+    iot2050_setup_uart(b, "UART0", "/dev/ttyS1", "IO0", "IO1", "IO2", "IO3");
+    b->def_uart_dev = 0;
+    /* I2C */
+    iot2050_setup_i2c(b, "I2C0", 4, "A4", "A5");
+    b->def_i2c_bus = 0;
+    /* SPI */
+    iot2050_setup_spi(b, "SPI0", 0, 0, "IO13", "IO11", "IO12", "IO10");
+    b->def_spi_bus = 0;
+    /* PWM */
+    iot2050_setup_pwm(b, "PWM0");
+    iot2050_setup_pwm(b, "PWM1");
+    iot2050_setup_pwm(b, "PWM2");
+    iot2050_setup_pwm(b, "PWM3");
+    iot2050_setup_pwm(b, "PWM4");
+    iot2050_setup_pwm(b, "PWM5");
+    b->def_pwm_dev = 0;
+    /* LED */
+    iot2050_setup_led(b, "user-led1-green");
+    iot2050_setup_led(b, "user-led1-red");
+    iot2050_setup_led(b, "user-led2-green");
+    iot2050_setup_led(b, "user-led2-red");
+    return b;
+error:
+    syslog(LOG_CRIT, "iot2050: Platform failed to initialise");
+    free(b);
+    return NULL;
+}
diff --git a/src/arm/siemens/platform.c b/src/arm/siemens/platform.c
new file mode 100644
index 0000000..b20a1e8
--- /dev/null
+++ b/src/arm/siemens/platform.c
@@ -0,0 +1,41 @@
+/*
+ * Author: Le Jin <le.jin@siemens.com>
+ * Copyright (c) Siemens AG, 2019
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <string.h>
+#include "arm/siemens/platform.h"
+#include "arm/siemens/platform_iot2050.h"
+
+void *
+platfrom_pinmux_get_instance(char *platform)
+{
+    PinMuxInterface_t *instance = NULL;
+    if(!strcmp(platform, "iot2050")) {
+        instance = iot2050_pinmux_get_instance();
+    }
+    if((instance) && (instance->initialized == false) && (instance->ops.init)) {
+        return instance->ops.init()?instance:NULL;
+    }
+    else {
+        return NULL;
+    }
+}
diff --git a/src/arm/siemens/platform_iot2050.c b/src/arm/siemens/platform_iot2050.c
new file mode 100644
index 0000000..89d12b9
--- /dev/null
+++ b/src/arm/siemens/platform_iot2050.c
@@ -0,0 +1,367 @@
+/*
+ * Author: Le Jin <le.jin@siemens.com>
+ * Copyright (c) Siemens AG, 2019
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include "arm/siemens/platform_iot2050.h"
+
+enum{
+    GROUP_MAIN_DOMAIN = 0,
+    GROUP_WAKUP_DOMAIN,
+    MAX_GROUP_NUMBER
+};
+
+typedef struct{
+    PinMuxInterface_t       super;
+    int                     memFd;
+    volatile uint32_t       *pinMuxRegBase[MAX_GROUP_NUMBER];
+    volatile void           *mapAddress[MAX_GROUP_NUMBER];
+}IOT2050PinMuxHandler_t;
+
+static bool iot2050_pinmux_init(void);
+static void iot2050_pinmux_deinit(void);
+static void iot2050_pinmux_select_func(uint8_t group, uint16_t pinIndex, uint8_t func);
+static void iot2050_pinmux_select_input(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_select_output(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_select_inout(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_select_hiz(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_select_pull_up(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_select_pull_down(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_select_pull_disable(uint8_t group, uint16_t pinIndex);
+static uint32_t iot2050_pinmux_get_raw_reg_value(uint8_t group, uint16_t pinIndex);
+static void iot2050_pinmux_set_raw_reg_value(uint8_t group, uint16_t pinIndex, uint32_t value);
+static void iot2050_pinmux_dump_info(uint8_t group, uint16_t pinIndex);
+
+#define MAIN_PINMUX_REG_NUM                 (195)
+#define MAIN_PINMUX_REG_LENGTH              (MAIN_PINMUX_REG_NUM<<2)
+#define MAIN_PINMUX_REG_PHY_BASE_ADDRESS    (0x0011c000)
+
+#define WAKUP_PINMUX_REG_NUM                (70)
+#define WAKUP_PINMUX_REG_LENGTH             (WAKUP_PINMUX_REG_NUM<<2)
+#define WAKUP_PINMUX_REG_PHY_BASE_ADDRESS   (0x4301c000)
+
+#define PAGE_SIZE 4096UL
+#define PAGE_MASK (PAGE_SIZE - 1)
+
+#define REG_MUXMODE_POS             (0)
+#define REG_MUXMODE_MASK            (0x0F << REG_MUXMODE_POS)
+#define REG_MUXMODE_GET(reg)        ((reg & REG_MUXMODE_MASK) >> REG_MUXMODE_POS)
+#define REG_MUXMODE(mode)           ((mode << REG_MUXMODE_POS) & REG_MUXMODE_MASK)
+
+#define REG_PULL_ENABLE_POS         (16)
+#define REG_PULL_ENABLE_MASK        (0x01 << REG_PULL_ENABLE_POS)
+#define REG_PULL_ENABLE_GET(reg)    ((reg & REG_PULL_ENABLE_MASK) >> REG_PULL_ENABLE_POS)
+#define REG_PULL_ENABLE             (0x00 << REG_PULL_ENABLE_POS)
+#define REG_PULL_DISABLE            (0x01 << REG_PULL_ENABLE_POS)
+#define REG_PULL_IS_ENABLED(reg)    (!REG_PULL_ENABLE_GET(reg))
+#define REG_PULL_IS_DISABLED(reg)   (!REG_PULL_IS_ENABLED(reg))
+
+#define REG_PULL_SELECT_POS         (17)
+#define REG_PULL_SELECT_MASK        (0x01 << REG_PULL_SELECT_POS)
+#define REG_PULL_SELECT_GET(reg)    ((reg & REG_PULL_SELECT_MASK) >> REG_PULL_SELECT_POS)
+#define REG_PULL_UP                 (0x01 << REG_PULL_SELECT_POS)
+#define REG_PULL_DOWN               (0x00 << REG_PULL_SELECT_POS)
+#define REG_PULL_IS_UP(reg)         (REG_PULL_SELECT_GET(reg))
+#define REG_PULL_IS_DOWN(reg)       (!REG_PULL_IS_UP(reg))
+
+#define REG_INPUT_ENABLE_POS        (18)
+#define REG_INPUT_ENABLE_MASK       (0x01 << REG_INPUT_ENABLE_POS)
+#define REG_INPUT_ENABLE_GET(reg)   ((reg & REG_INPUT_ENABLE_MASK) >> REG_INPUT_ENABLE_POS)
+#define REG_INPUT_ENABLE            (0x01 << REG_INPUT_ENABLE_POS)
+#define REG_INPUT_DISABLE           (0x00 << REG_INPUT_ENABLE_POS)
+#define REG_INPUT_IS_ENABLED(reg)   (REG_INPUT_ENABLE_GET(reg))
+#define REG_INPUT_IS_DISABLED(reg)  (!REG_INPUT_IS_ENABLED(reg))
+
+#define REG_OUTPUT_ENABLE_POS       (21)
+#define REG_OUTPUT_ENABLE_MASK      (0x01 << REG_OUTPUT_ENABLE_POS)
+#define REG_OUTPUT_ENABLE_GET(reg)  ((reg & REG_OUTPUT_ENABLE_MASK) >> REG_OUTPUT_ENABLE_POS)
+#define REG_OUTPUT_ENABLE           (0x00 << REG_OUTPUT_ENABLE_POS)
+#define REG_OUTPUT_DISABLE          (0x01 << REG_OUTPUT_ENABLE_POS)
+#define REG_OUTPUT_IS_ENABLED(reg)  (!REG_OUTPUT_ENABLE_GET(reg))
+#define REG_OUTPUT_IS_DISABLED(reg) (!REG_OUTPUT_IS_ENABLED(reg))
+
+#define REG_UPDATE(address, mask, value)        (*address = ((*address) & (~mask)) | (value))
+#define GROUP_IS_VALID(group)                   (group < MAX_GROUP_NUMBER)
+
+#define PIN_OUTPUT		(PULL_DISABLE)
+#define PIN_OUTPUT_PULLUP	(PULL_UP)
+#define PIN_OUTPUT_PULLDOWN	0
+#define PIN_INPUT		(INPUT_EN | PULL_DISABLE)
+#define PIN_INPUT_PULLUP	(INPUT_EN | PULL_UP)
+#define PIN_INPUT_PULLDOWN	(INPUT_EN)
+
+static IOT2050PinMuxHandler_t iot2050PinMuxHandler = {
+    .super = {
+        .initialized = false,
+        .ops = {
+            .init = iot2050_pinmux_init,
+            .deinit = iot2050_pinmux_deinit,
+            .select_func = iot2050_pinmux_select_func,
+            .select_input = iot2050_pinmux_select_input,
+            .select_output = iot2050_pinmux_select_output,
+            .select_inout = iot2050_pinmux_select_inout,
+            .select_hiz = iot2050_pinmux_select_hiz,
+            .select_pull_up = iot2050_pinmux_select_pull_up,
+            .select_pull_down = iot2050_pinmux_select_pull_down,
+            .select_pull_disable = iot2050_pinmux_select_pull_disable,
+            .get_raw_reg_value = iot2050_pinmux_get_raw_reg_value,
+            .set_raw_reg_value = iot2050_pinmux_set_raw_reg_value,
+            .dump_info = iot2050_pinmux_dump_info
+        }
+    },
+    .memFd = -1,
+    .mapAddress[GROUP_MAIN_DOMAIN] = MAP_FAILED,
+    .mapAddress[GROUP_WAKUP_DOMAIN] = MAP_FAILED,
+    .pinMuxRegBase[GROUP_MAIN_DOMAIN] = MAP_FAILED,
+    .pinMuxRegBase[GROUP_WAKUP_DOMAIN] = MAP_FAILED
+};
+
+PinMuxInterface_t*
+iot2050_pinmux_get_instance(void) 
+{
+    return (PinMuxInterface_t *)&iot2050PinMuxHandler;
+}
+
+static bool
+iot2050_pinmux_init(void)
+{
+    uint32_t pageMask = sysconf(_SC_PAGE_SIZE) - 1;
+
+    /* Open memory */
+    DEBUG_PRINT("Open device\n");
+    if((iot2050PinMuxHandler.memFd = open("/dev/mem", O_RDWR | O_SYNC)) == -1) {
+        DEBUG_PRINT("Open device: %s\n", strerror(errno));
+        goto _FATAL;
+    }
+
+    /* Map */
+    DEBUG_PRINT("Map main mux register base\n");
+    iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN] = mmap(0, MAIN_PINMUX_REG_LENGTH,
+                                                    PROT_READ | PROT_WRITE, MAP_SHARED,
+                                                    iot2050PinMuxHandler.memFd,
+                                                    MAIN_PINMUX_REG_PHY_BASE_ADDRESS & ~pageMask);
+    if(iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN] == MAP_FAILED) {
+        DEBUG_PRINT("Pinmux main domain map failed: %s\n", strerror(errno));
+        goto _FATAL;
+    }
+    iot2050PinMuxHandler.pinMuxRegBase[GROUP_MAIN_DOMAIN] = iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN] + 
+                                        (MAIN_PINMUX_REG_PHY_BASE_ADDRESS & pageMask);
+    DEBUG_PRINT("\tPage address: %p\n", iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN]);
+    DEBUG_PRINT("\tIn-page Offset: %x\n", MAIN_PINMUX_REG_PHY_BASE_ADDRESS & pageMask);
+    DEBUG_PRINT("\tReg address: %p\n", iot2050PinMuxHandler.pinMuxRegBase[GROUP_MAIN_DOMAIN]);
+    DEBUG_PRINT("Map wakup mux register base\n");
+    iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN] = mmap(0, WAKUP_PINMUX_REG_LENGTH,
+                                                    PROT_READ | PROT_WRITE, MAP_SHARED,
+                                                    iot2050PinMuxHandler.memFd,
+                                                    WAKUP_PINMUX_REG_PHY_BASE_ADDRESS & ~pageMask);
+    if(iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN] == MAP_FAILED) {
+        DEBUG_PRINT("Pinmux wakup domain map failed: %s\n", strerror(errno));
+        goto _FATAL;
+    }
+    iot2050PinMuxHandler.pinMuxRegBase[GROUP_WAKUP_DOMAIN] = iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN] + 
+                                        (WAKUP_PINMUX_REG_PHY_BASE_ADDRESS & pageMask);
+    DEBUG_PRINT("\tPage address: %p\n", iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN]);
+    DEBUG_PRINT("\tIn-page Offset: %x\n", WAKUP_PINMUX_REG_PHY_BASE_ADDRESS & pageMask);
+    DEBUG_PRINT("\tReg address: %p\n", iot2050PinMuxHandler.pinMuxRegBase[GROUP_WAKUP_DOMAIN]);
+    iot2050PinMuxHandler.super.initialized = true;
+    return true;
+_FATAL:
+    iot2050_pinmux_deinit();
+    return false;
+}
+
+static void
+iot2050_pinmux_deinit(void)
+{
+    if(iot2050PinMuxHandler.memFd > 0)
+        close(iot2050PinMuxHandler.memFd);
+    iot2050PinMuxHandler.memFd = -1;
+    if(iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN] != MAP_FAILED)
+        munmap((void *)iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN], MAIN_PINMUX_REG_LENGTH);
+    iot2050PinMuxHandler.mapAddress[GROUP_MAIN_DOMAIN] = MAP_FAILED;
+    iot2050PinMuxHandler.pinMuxRegBase[GROUP_MAIN_DOMAIN] = MAP_FAILED;
+
+    if(iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN] != MAP_FAILED)
+        munmap((void *)iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN], WAKUP_PINMUX_REG_LENGTH);
+    iot2050PinMuxHandler.mapAddress[GROUP_WAKUP_DOMAIN] = MAP_FAILED;
+    iot2050PinMuxHandler.pinMuxRegBase[GROUP_WAKUP_DOMAIN] = MAP_FAILED;
+    iot2050PinMuxHandler.super.initialized = false;
+}
+
+static void
+iot2050_pinmux_select_func(uint8_t group, uint16_t pinIndex, uint8_t func) {
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_MUXMODE_MASK, REG_MUXMODE(func));
+    }
+}
+
+static void
+iot2050_pinmux_select_input(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_INPUT_ENABLE_MASK, REG_INPUT_ENABLE);
+        REG_UPDATE(regVirtualAddress, REG_OUTPUT_ENABLE_MASK, REG_OUTPUT_DISABLE);
+    }
+}
+
+static void
+iot2050_pinmux_select_output(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_INPUT_ENABLE_MASK, REG_INPUT_DISABLE);
+        REG_UPDATE(regVirtualAddress, REG_OUTPUT_ENABLE_MASK, REG_OUTPUT_ENABLE);
+    }
+}
+
+static void
+iot2050_pinmux_select_inout(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_INPUT_ENABLE_MASK, REG_INPUT_ENABLE);
+        REG_UPDATE(regVirtualAddress, REG_OUTPUT_ENABLE_MASK, REG_OUTPUT_ENABLE);
+    }
+}
+
+static void
+iot2050_pinmux_select_hiz(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_INPUT_ENABLE_MASK, REG_INPUT_DISABLE);
+        REG_UPDATE(regVirtualAddress, REG_OUTPUT_ENABLE_MASK, REG_OUTPUT_DISABLE);
+    }
+}
+
+
+static void
+iot2050_pinmux_select_pull_up(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_PULL_ENABLE_MASK, REG_PULL_ENABLE);
+        REG_UPDATE(regVirtualAddress, REG_PULL_SELECT_MASK, REG_PULL_UP);
+    }
+}
+
+static void
+iot2050_pinmux_select_pull_down(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_PULL_ENABLE_MASK, REG_PULL_ENABLE);
+        REG_UPDATE(regVirtualAddress, REG_PULL_SELECT_MASK, REG_PULL_DOWN);
+    }
+}
+
+static void
+iot2050_pinmux_select_pull_disable(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        REG_UPDATE(regVirtualAddress, REG_PULL_ENABLE_MASK, REG_PULL_DISABLE);
+    }
+}
+
+static uint32_t
+iot2050_pinmux_get_raw_reg_value(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        return *regVirtualAddress;
+    }
+    return -1;
+}
+
+static void
+iot2050_pinmux_set_raw_reg_value(uint8_t group, uint16_t pinIndex, uint32_t value)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        *regVirtualAddress = value;
+    }
+}
+
+static void
+iot2050_pinmux_dump_info(uint8_t group, uint16_t pinIndex)
+{
+    volatile uint32_t *regVirtualAddress;
+
+    if(GROUP_IS_VALID(group)) {
+        regVirtualAddress = iot2050PinMuxHandler.pinMuxRegBase[group] + pinIndex;
+        fprintf(stderr, "PinmuxReg Domain %s, Index %d, Raw 0x%08x\n",
+                        group?"Wakup":"Main",
+                        pinIndex,
+                        iot2050_pinmux_get_raw_reg_value(group, pinIndex));
+        if(REG_INPUT_IS_ENABLED(*regVirtualAddress)) {
+            fprintf(stderr, "\tInput: enabled\n");
+        }
+        else if(REG_OUTPUT_IS_ENABLED(*regVirtualAddress)) {
+            fprintf(stderr, "\tOutput: enabled\n");
+        }
+        else {
+            fprintf(stderr, "\tOutput: Hiz\n");
+        }
+
+        if(REG_PULL_IS_ENABLED(*regVirtualAddress)) {
+            if(REG_PULL_IS_UP(*regVirtualAddress)) {
+                fprintf(stderr, "\tPull Status: up\n");
+            }
+            else {
+                fprintf(stderr, "\tPull Status: down\n");
+            }
+        }
+        else {
+            fprintf(stderr, "\tPull Status: disabled\n");
+        }
+        fprintf(stderr, "\tMode: %d\n", REG_MUXMODE_GET(*regVirtualAddress));
+    }
+}
diff --git a/src/gpio/gpio.c b/src/gpio/gpio.c
index d1a41ad..ff97b4b 100644
--- a/src/gpio/gpio.c
+++ b/src/gpio/gpio.c
@@ -309,7 +309,12 @@ mraa_gpio_init(int pin)
             return NULL;
         }
     }
-
+    if (board->adv_func->setup_mux_register) {
+        if(board->adv_func->setup_mux_register(pin, MUX_REGISTER_MODE_GPIO) != MRAA_SUCCESS) {
+            syslog(LOG_ERR, "gpio%i: init: unable to setup multiplex register", pin);
+            return NULL;
+        }
+    }
     mraa_gpio_context r = mraa_gpio_init_internal(board->adv_func, board->pins[pin].gpio.pinmap);
 
     if (r == NULL) {
@@ -408,6 +413,13 @@ mraa_gpio_chardev_init(int pins[], int num_pins)
             }
         }
 
+        if (board->adv_func->setup_mux_register) {
+            if(board->adv_func->setup_mux_register(pins[i], MUX_REGISTER_MODE_GPIO) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "[GPIOD_INTERFACE]: init: unable to setup mux register for pin %d", pins[i]);
+                mraa_gpio_close(dev);
+                return NULL;
+            }
+        }
         chip_id = board->pins[pins[i]].gpio.gpio_chip;
         line_offset = board->pins[pins[i]].gpio.gpio_line;
 
diff --git a/src/i2c/i2c.c b/src/i2c/i2c.c
index 5301929..b2d7b20 100644
--- a/src/i2c/i2c.c
+++ b/src/i2c/i2c.c
@@ -156,7 +156,12 @@ mraa_i2c_init(int bus)
                 return NULL;
             }
         }
-
+        if (pos >= 0 && board->adv_func->setup_mux_register) {
+            if(board->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_I2C) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "i2c%i_init: Failed to set-up i2c sda multiplex register", bus);
+                return NULL;
+            }
+        }
         pos = board->i2c_bus[bus].scl;
         if (pos >=0 && board->pins[pos].i2c.mux_total > 0) {
             if (mraa_setup_mux_mapped(board->pins[pos].i2c) != MRAA_SUCCESS) {
@@ -164,6 +169,12 @@ mraa_i2c_init(int bus)
                 return NULL;
             }
         }
+        if (pos >= 0 && board->adv_func->setup_mux_register) {
+            if(board->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_I2C) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "i2c%i_init: Failed to set-up scl sda multiplex register", bus);
+                return NULL;
+            }
+        }
     }
 
     return mraa_i2c_init_internal(board->adv_func, (unsigned int) board->i2c_bus[bus].bus_id);
diff --git a/src/mraa.c b/src/mraa.c
index 927d9ab..f31ffbc 100644
--- a/src/mraa.c
+++ b/src/mraa.c
@@ -393,6 +393,7 @@ mraa_setup_mux_mapped(mraa_pin_t meta)
 
     for (mi = 0; mi < meta.mux_total; mi++) {
 
+        syslog(LOG_DEBUG, "PINMUX[%d] cmd %d pin %d\n", mi, meta.mux[mi].pincmd, meta.mux[mi].pin);
         switch (meta.mux[mi].pincmd) {
             case PINCMD_UNDEFINED: // used for backward compatibility
                 if (meta.mux[mi].pin != last_pin) {
diff --git a/src/pwm/pwm.c b/src/pwm/pwm.c
index 651d086..789931c 100644
--- a/src/pwm/pwm.c
+++ b/src/pwm/pwm.c
@@ -240,6 +240,13 @@ mraa_pwm_init(int pin)
         }
     }
 
+    if (board->adv_func->setup_mux_register) {
+        if(board->adv_func->setup_mux_register(pin, MUX_REGISTER_MODE_PWM) != MRAA_SUCCESS) {
+            syslog(LOG_ERR, "pwm_init: Failed to set-up pwm%i multiplex register", pin);
+            return NULL;
+        }
+    }
+
     int chip = board->pins[pin].pwm.parent_id;
     int pinn = board->pins[pin].pwm.pinmap;
 
diff --git a/src/spi/spi.c b/src/spi/spi.c
index 274af67..07e0678 100644
--- a/src/spi/spi.c
+++ b/src/spi/spi.c
@@ -81,6 +81,13 @@ mraa_spi_init(int bus)
             }
         }
 
+        if (pos >= 0 && plat->adv_func->setup_mux_register) {
+            if(plat->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_SPI) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "spi: failed to set-up spi sclk multiplex register");
+                return NULL;
+            }
+        }
+
         pos = plat->spi_bus[bus].mosi;
         if (pos >= 0 && plat->pins[pos].spi.mux_total > 0) {
             if (mraa_setup_mux_mapped(plat->pins[pos].spi) != MRAA_SUCCESS) {
@@ -89,6 +96,13 @@ mraa_spi_init(int bus)
             }
         }
 
+        if (pos >= 0 && plat->adv_func->setup_mux_register) {
+            if(plat->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_SPI) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "spi: failed to set-up spi mosi multiplex register");
+                return NULL;
+            }
+        }
+
         pos = plat->spi_bus[bus].miso;
         if (pos >= 0 && plat->pins[pos].spi.mux_total > 0) {
             if (mraa_setup_mux_mapped(plat->pins[pos].spi) != MRAA_SUCCESS) {
@@ -97,6 +111,13 @@ mraa_spi_init(int bus)
             }
         }
 
+        if (pos >= 0 && plat->adv_func->setup_mux_register) {
+            if(plat->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_SPI) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "spi: failed to set-up spi miso multiplex register");
+                return NULL;
+            }
+        }
+
         pos = plat->spi_bus[bus].cs;
         if (pos >= 0 && plat->pins[pos].spi.mux_total > 0) {
             if (mraa_setup_mux_mapped(plat->pins[pos].spi) != MRAA_SUCCESS) {
@@ -104,6 +125,13 @@ mraa_spi_init(int bus)
                 return NULL;
             }
         }
+
+        if (pos >= 0 && plat->adv_func->setup_mux_register) {
+            if(plat->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_SPI) != MRAA_SUCCESS) {
+                syslog(LOG_ERR, "spi: failed to set-up spi cs multiplex register");
+                return NULL;
+            }
+        }
     }
     mraa_spi_context dev = mraa_spi_init_raw(plat->spi_bus[bus].bus_id, plat->spi_bus[bus].slave_s);
 
diff --git a/src/uart/uart.c b/src/uart/uart.c
index f1a76d2..f1405f8 100644
--- a/src/uart/uart.c
+++ b/src/uart/uart.c
@@ -114,6 +114,7 @@ static unsigned int speed_to_uint(speed_t speedt) {
         { B1200, 1200 },
         { B1800, 1800 },
         { B2400, 2400 },
+        { B4800, 4800 },
         { B9600, 9600 },
         { B19200, 19200 },
         { B38400, 38400 },
@@ -201,6 +202,12 @@ mraa_uart_init(int index)
                     return NULL;
                 }
             }
+            if (plat->adv_func->setup_mux_register) {
+                if(plat->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_UART) != MRAA_SUCCESS) {
+                    syslog(LOG_ERR, "uart%i: init: failed to setup mux register for RX pin", index);
+                    return NULL;
+                }
+            }
         }
 
         pos = plat->uart_dev[index].tx;
@@ -211,6 +218,12 @@ mraa_uart_init(int index)
                     return NULL;
                 }
             }
+            if (plat->adv_func->setup_mux_register) {
+                if(plat->adv_func->setup_mux_register(pos, MUX_REGISTER_MODE_UART) != MRAA_SUCCESS) {
+                    syslog(LOG_ERR, "uart%i: init: failed to setup mux register for TX pin", index);
+                    return NULL;
+                }
+            }
         }
     }
 
@@ -606,12 +619,24 @@ mraa_uart_set_flowcontrol(mraa_uart_context dev, mraa_boolean_t xonxoff, mraa_bo
                         return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
                     }
                 }
+                if (plat->adv_func->setup_mux_register) {
+                    if(plat->adv_func->setup_mux_register(pos_cts, MUX_REGISTER_MODE_UART) != MRAA_SUCCESS) {
+                        syslog(LOG_ERR, "uart%i: init: failed to setup mux register for CTS pin", dev->index);
+                        return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+                    }
+                }
                 if (plat->pins[pos_rts].uart.mux_total > 0) {
                     if (mraa_setup_mux_mapped(plat->pins[pos_rts].uart) != MRAA_SUCCESS) {
                         syslog(LOG_ERR, "uart%i: init: failed to setup muxes for RTS pin", dev->index);
                         return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
                     }
                 }
+                if (plat->adv_func->setup_mux_register) {
+                    if(plat->adv_func->setup_mux_register(pos_rts, MUX_REGISTER_MODE_UART) != MRAA_SUCCESS) {
+                        syslog(LOG_ERR, "uart%i: init: failed to setup mux register for RTS pin", dev->index);
+                        return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+                    }
+                }
             }
         }
     }
@@ -672,7 +697,14 @@ mraa_uart_set_timeout(mraa_uart_context dev, int read, int write, int interchar)
             read = 1;
     }
     termio.c_lflag &= ~ICANON; /* Set non-canonical mode */
-    termio.c_cc[VTIME] = read; /* Set timeout in tenth seconds */
+    if (read > 0) {
+	termio.c_cc[VTIME] = read; /* Set timeout in tenth seconds */
+	termio.c_cc[VMIN]  = 0;
+    } else {
+	termio.c_cc[VTIME] = 0;   /* read <= 0 will disable timeout */
+	termio.c_cc[VMIN]  = 1;
+    }
+
     if (tcsetattr(dev->fd, TCSANOW, &termio) < 0) {
         syslog(LOG_ERR, "uart%i: set_timeout: tcsetattr() failed: %s", dev->index, strerror(errno));
         return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
-- 
2.26.2

